-----------------------------------------------------------------------------------------------------------------------

-- Normalizza Partecipante/Chef con Username minuscolo, CodiceFiscale Maiuscolo, Email minuscolo, Nome e Cognome con l'iniziale Maiuscola

CREATE OR REPLACE FUNCTION fun_normalizza_utente()
RETURNS TRIGGER AS
$$
BEGIN
    NEW.Username := LOWER(NEW.Username);
    NEW.CodiceFiscale := UPPER(NEW.CodiceFiscale);
    NEW.Email := LOWER(NEW.Email);
    NEW.Nome := INITCAP(NEW.Nome);
    NEW.Cognome := INITCAP(NEW.Cognome);
    RETURN NEW;

END fun_normalizza_utente;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_normalizza_partecipante
BEFORE INSERT OR UPDATE ON Partecipante
FOR EACH ROW
EXECUTE FUNCTION fun_normalizza_utente();

CREATE TRIGGER trg_normalizza_chef
BEFORE INSERT OR UPDATE ON Chef
FOR EACH ROW
EXECUTE FUNCTION fun_normalizza_utente();


-- Normalizzo Ingrediente e Ricetta con l'iniziale del nome maiuscola

CREATE OR REPLACE FUNCTION fun_normalizza_ingr_chef()
RETURNS TRIGGER AS
$$
BEGIN
    NEW.Nome := INITCAP(NEW.Nome);
    RETURN NEW;

END fun_normalizza_ingr_chef;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_normalizza_ingrediente
BEFORE INSERT OR UPDATE ON Ingrediente
FOR EACH ROW
EXECUTE FUNCTION fun_normalizza_ingr_chef();

CREATE TRIGGER trg_normalizza_ricetta
BEFORE INSERT OR UPDATE ON Ricetta
FOR EACH ROW
EXECUTE FUNCTION fun_normalizza_ingr_chef();

-----------------------------------------------------------------------------------------------------------------------

-- Interrelazionale: Impedire che due utenti – uno Chef e uno Partecipante – abbiano lo stesso Username, anche se sono in due tabelle diverse.

CREATE OR REPLACE FUNCTION fun_username_unique()
RETURNS TRIGGER AS
$$
BEGIN
	IF TG_OP = 'UPDATE' AND NEW.Username = OLD.Username THEN			-- Ottimizzazione se è una update e lo username non cambia
    		RETURN NEW;
	END IF;

	IF TG_TABLE_NAME = 'Partecipante' THEN
    		IF EXISTS (SELECT 1 FROM Chef WHERE Username = NEW.Username) THEN
    			RAISE EXCEPTION 'Username già usato in Chef';
		END IF;
	END IF;
	
	IF TG_TABLE_NAME = 'Chef' THEN
		IF EXISTS (SELECT 1 FROM Partecipante WHERE Username = NEW.Username) THEN
    			RAISE EXCEPTION 'Username già usato in Partecipante';
		END IF;
	END IF;
	RETURN NEW;

END fun_username_unique;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_unico_username_partecipante
BEFORE INSERT OR UPDATE ON Partecipante 
FOR EACH ROW
EXECUTE FUNCTION fun_username_unique();

CREATE TRIGGER trg_unico_username_chef
BEFORE INSERT OR UPDATE ON Chef 
FOR EACH ROW
EXECUTE FUNCTION fun_username_unique();

-----------------------------------------------------------------------------------------------------------------------

-- Interrelazionale: La Data della sessione deve essere maggiore o uguale della data di inizio corso (sia per pratica che per online)

CREATE OR REPLACE FUNCTION fun_data_sessione()
RETURNS TRIGGER AS
$$
DECLARE
	Data_Corso Corso.DataInizio%TYPE;

BEGIN
	SELECT C.DataInizio INTO Data_Corso FROM Corso C WHERE C.IdCorso = NEW.IdCorso;

	IF NEW.Data < Data_Corso THEN
		RAISE EXCEPTION 'La sessione deve avere una data successiva all''inizio del corso';
	END IF;
	RETURN NEW;

END fun_data_sessione;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_data_sessione_online
BEFORE INSERT OR UPDATE ON SessioneOnline
FOR EACH ROW
EXECUTE FUNCTION fun_data_sessione();

CREATE TRIGGER trg_data_sessione_pratica
BEFORE INSERT OR UPDATE ON SessionePratica
FOR EACH ROW
EXECUTE FUNCTION fun_data_sessione();

-----------------------------------------------------------------------------------------------------------------------

-- Interrelazionale: Non ci possono essere più sessioni per lo stesso corso nello stesso giorno

CREATE OR REPLACE FUNCTION fun_unicita_sessione_giorno()
RETURNS TRIGGER AS
$$
BEGIN
    	IF EXISTS ( SELECT 1 FROM SessioneOnline WHERE Data = NEW.Data AND IdCorso = NEW.IdCorso ) THEN
    		RAISE EXCEPTION 'C'è già una sessione online lo stesso giorno';
	END IF;

    	IF EXISTS ( SELECT 1 FROM SessionePratica WHERE Data = NEW.Data AND IdCorso = NEW.IdCorso) THEN
    		RAISE EXCEPTION 'C'è già una sessione pratica lo stesso giorno';
	END IF;
    	RETURN NEW;

END fun_unicita_sessione_giorno;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_unicita_sessione_online_giorno
BEFORE INSERT OR UPDATE ON SessioneOnline
FOR EACH ROW
EXECUTE FUNCTION fun_unicita_sessione_giorno();

CREATE TRIGGER trg_unicita_sessione_pratica_giorno
BEFORE INSERT OR UPDATE ON SessionePratica
FOR EACH ROW
EXECUTE FUNCTION fun_unicita_sessione_giorno();

-----------------------------------------------------------------------------------------------------------------------

-- Aggiornamento numero sessioni (increment)

CREATE OR REPLACE FUNCTION fun_incrementa_num_sessioni()
RETURNS TRIGGER AS
$$
BEGIN
    	UPDATE Corso
    	SET NumeroSessioni = NumeroSessioni + 1
    	WHERE IdCorso = NEW.IdCorso;
    	RETURN NULL;

END fun_incrementa_num_sessioni;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_incremento_numsessioni_online
AFTER INSERT ON SessioneOnline
FOR EACH ROW
EXECUTE FUNCTION fun_incrementa_num_sessioni();

CREATE TRIGGER trg_incremento_numsessioni_pratiche
AFTER INSERT ON SessionePratica
FOR EACH ROW
EXECUTE FUNCTION fun_incrementa_num_sessioni();


-- Aggiornamento numero sessioni (decrement)

CREATE OR REPLACE FUNCTION fun_decrementa_num_sessioni()
RETURNS TRIGGER AS
$$
BEGIN
	UPDATE Corso
	SET NumeroSessioni = GREATEST(NumeroSessioni - 1, 0)
	WHERE IdCorso = OLD.IdCorso;
	RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_decrementa_num_sessioni_pratica
AFTER DELETE ON SessionePratica
FOR EACH ROW
EXECUTE FUNCTION fun_decrementa_num_sessioni();

CREATE TRIGGER trg_decrementa_num_sessioni_online
AFTER DELETE ON SessioneOnline
FOR EACH ROW
EXECUTE FUNCTION fun_decrementa_num_sessioni();

-----------------------------------------------------------------------------------------------------------------------

-- Trigger aggiornamento numero utenti (increment)

CREATE OR REPLACE FUNCTION fun_incrementa_num_utenti()
RETURNS TRIGGER AS
$$    
BEGIN
    UPDATE SessionePratica
    SET NumeroUtenti = NumeroUtenti + 1
    WHERE IdSessionePratica = NEW.IdSessionePratica;
    RETURN NULL;

END fun_incrementa_num_utenti;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_incremento_numutenti
AFTER INSERT ON Adesioni
FOR EACH ROW
EXECUTE FUNCTION fun_incrementa_num_utenti();


-- Trigger aggiornamento numero utenti (decrement)

CREATE OR REPLACE FUNCTION fun_decrementa_num_utenti()
RETURNS TRIGGER AS
$$
BEGIN
	UPDATE SessionePratica
	SET NumeroUtenti = GREATEST(NumeroUtenti - 1, 0)
	WHERE IdSessionePratica = OLD.IdSessionePratica;
	RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_decrementa_num_utenti
AFTER DELETE ON Adesioni
FOR EACH ROW
EXECUTE FUNCTION fun_decrementa_num_utenti();

-----------------------------------------------------------------------------------------------------------------------

-- Trigger aggiornamento numero corsi(increment)

CREATE OR REPLACE FUNCTION fun_incrementa_num_corsi()
RETURNS TRIGGER AS
$$    
BEGIN
    UPDATE Partecipante
    SET NumeroCorsi = NumeroCorsi + 1
    WHERE IdPartecipante = NEW.IdPartecipante;
    RETURN NULL;

END fun_incrementa_num_corsi;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_incrementa_num_corsi
AFTER INSERT ON Iscrizioni
FOR EACH ROW
EXECUTE FUNCTION fun_incrementa_num_corsi();


-- Trigger aggiornamento numero corsi(decrement)

CREATE OR REPLACE FUNCTION fun_decrementa_num_corsi()
RETURNS TRIGGER AS
$$    
BEGIN
    UPDATE Partecipante
    SET NumeroCorsi = GREATEST(NumeroCorsi - 1, 0)
    WHERE IdPartecipante = OLD.IdPartecipante;
    RETURN OLD;

END fun_decrementa_num_corsi;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_decrementa_num_corsi
AFTER DELETE ON Iscrizioni
FOR EACH ROW
EXECUTE FUNCTION fun_decrementa_num_corsi();

-----------------------------------------------------------------------------------------------------------------------

-- Interrelazionale: La data dell'adesione alla sessione pratica deve essere antecedente alla data della sessione pratica/ Se la sessione pratica è già avvenuta, l'utente non puo' più aderire

CREATE OR REPLACE FUNCTION fun_data_adesione()
RETURNS TRIGGER AS
$$
DECLARE
    	Data_Sessione SessionePratica.Data%TYPE;

BEGIN

    	SELECT Data INTO Data_Sessione
    	FROM SessionePratica
    	WHERE IdSessionePratica = NEW.IdSessionePratica;

    	IF NEW.DataAdesione >= Data_Sessione  THEN
        	RAISE EXCEPTION 'L'' adesione deve essere antecedente alla data della sessione pratica';
    	END IF;
    	RETURN NEW;

END fun_data_adesione;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_data_adesione
BEFORE INSERT OR UPDATE ON Adesioni
FOR EACH ROW
EXECUTE FUNCTION fun_data_adesione();

-----------------------------------------------------------------------------------------------------------------------

-- Interrelazionale: Se viene inserita una partecipazione ma il limite di iscrizioni è già raggiunto, essa non viene inserita

CREATE OR REPLACE FUNCTION fun_limite_iscrizioni()
RETURNS TRIGGER AS
$$
DECLARE
    	numero_iscritti INTEGER;
    	limite_corso Corso.Limite%TYPE;
	pratico Corso.isPratico%TYPE;
BEGIN
	
	SELECT Limite, isPratico INTO limite_corso, pratico
    	FROM Corso
    	WHERE IdCorso = NEW.IdCorso;

	IF pratico THEN
    		SELECT COUNT(*) INTO numero_iscritti
    		FROM Iscrizioni
    		WHERE IdCorso = NEW.IdCorso;
    	
    		IF numero_iscritti >= limite_corso THEN
        		RAISE EXCEPTION 'Il limite delle iscrizioni per il corso è stato già raggiunto';
    		END IF;
	END IF;
    	RETURN NEW;

END fun_limite_iscrizioni;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_limite_iscrizioni 
BEFORE INSERT OR UPDATE ON Iscrizioni
FOR EACH ROW
EXECUTE FUNCTION fun_limite_iscrizioni();

-----------------------------------------------------------------------------------------------------------------------

-- Interrelazionale: Un utente non puo' partecipare a una sessione pratica se non iscritto al corso che la organizza

CREATE OR REPLACE FUNCTION fun_iscrizione_before_adesione()
RETURNS TRIGGER AS
$$
DECLARE
    	idcorso_sessione SessionePratica.IdCorso%TYPE;

BEGIN

    	SELECT IdCorso INTO idcorso_sessione
    	FROM SessionePratica
    	WHERE IdSessionePratica = NEW.IdSessionePratica;

	IF NOT EXISTS ( SELECT 1 FROM Iscrizioni WHERE IdPartecipante = NEW.IdPartecipante AND IdCorso = idcorso_sessione ) THEN
    		RAISE EXCEPTION 'Partecipante non iscritto al corso, impossibile aderire alla sessione pratica';
	END IF;
    	RETURN NEW;

END fun_iscrizione_before_adesione;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_iscrizione_before_adesione
BEFORE INSERT OR UPDATE ON Adesioni
FOR EACH ROW
EXECUTE FUNCTION fun_iscrizione_before_adesione();

-----------------------------------------------------------------------------------------------------------------------

-- BUSINESS IntraRelazionale: Gli argomenti del corso non possono essere più di 5

CREATE OR REPLACE FUNCTION fun_limit_argomenti()
RETURNS TRIGGER AS
$$
DECLARE
    	num_argomenti INTEGER;

BEGIN
	
	SELECT COUNT(*) INTO num_argomenti FROM Argomenti_Corso WHERE IdCorso = NEW.IdCorso;

	IF num_argomenti >= 5 THEN
		RAISE EXCEPTION 'E'' gia' stato scelto il numero massimo di argomenti per questo corso'; 
    	END IF;
    	RETURN NEW;

END fun_limit_argomenti;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_limit_argomenti
BEFORE INSERT OR UPDATE ON Argomenti_Corso
FOR EACH ROW
EXECUTE FUNCTION fun_limit_argomenti();

-----------------------------------------------------------------------------------------------------------------------

-- trigger su update di tipo pratiche, se diventa true allora imporre il limite altrimenti metti null

CREATE OR REPLACE FUNCTION fun_upd_tipo_corso()
RETURNS TRIGGER AS 
$$
BEGIN
	IF OLD.isPratico <> NEW.isPratico THEN
		IF NOT NEW.isPratico THEN
			NEW.Limite = NULL;
		END IF;  
	END IF; 	
	RETURN NEW;

END fun_upd_tipo_corso;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_upd_tipo_corso
BEFORE UPDATE ON Corso
FOR EACH ROW
EXECUTE FUNCTION fun_upd_tipo_corso();

-----------------------------------------------------------------------------------------------------------------------

-- Interrelazionale: Lo chef non può usare ricette nelle sessioni pratiche che non sono sue

CREATE OR REPLACE FUNCTION fun_ricette_chef_sessione()
RETURNS TRIGGER AS
$$
DECLARE
	id1 Chef.IdChef%TYPE;
	id2 Chef.IdChef%TYPE;
BEGIN
	SELECT IdChef INTO id1 FROM Preparazioni NATURAL JOIN Ricetta WHERE IdRicetta = NEW.IdRicetta;

	SELECT IdChef INTO id2 FROM Preparazioni NATURAL JOIN SessionePratica NATURAL JOIN Corso WHERE IdSessionePratica = NEW.IdSessionePratica;
	
	IF id1 <> id2 THEN
		RAISE EXCEPTION 'Non si possono inserire ricette che non sono dello chef';
	END IF;
	RETURN NEW;

END fun_ricette_chef_sessione;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_ricette_chef_sessione
BEFORE INSERT OR UPDATE ON Preparazioni
FOR EACH ROW
EXECUTE FUNCTION fun_ricette_chef_sessione();





